/* $Id: canvas.cpp 54604 2012-07-07 00:49:45Z loonycyborg $ */
/*
   Copyright (C) 2007 - 2012 by Mark de Wever <koraq@xs4all.nl>
   Part of the Battle for Wesnoth Project http://www.wesnoth.org/

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY.

   See the COPYING file for more details.
*/

/**
 * @file
 * Implementation of canvas.hpp.
 */

#define GETTEXT_DOMAIN "rose-lib"

#include "gui/auxiliary/canvas.hpp"

#include "config.hpp"
#include "../../image.hpp"
#include "formatter.hpp"
#include "gettext.hpp"
#include "gui/auxiliary/formula.hpp"
#include "gui/auxiliary/log.hpp"
#include "gui/widgets/helper.hpp"
#include "wml_exception.hpp"
#include "font.hpp"
#include "display.hpp"
#include "integrate.hpp"
#include "filesystem.hpp"

#include <boost/foreach.hpp>

void decode_hdpi_off(const std::string& hdpi_off, int size, bool* result)
{
	memset(result, 0, sizeof(bool) * size);
	if (hdpi_off.empty()) {
		return;
	}

	std::vector<std::string> fields = utils::split(hdpi_off);
	int size2 = fields.size();
	for (int at = 0; at < size; at ++) {
		if (at < size2) {
			result[at] = utils::to_bool(fields[at]);
		} else {
			return;
		}
	}
}

namespace gui2 {

class tblend_none_lock
{
public:
	tblend_none_lock(surface& surf)
		: surf_(surf)
	{
		SDL_GetSurfaceBlendMode(surf, &orignal_);
		if (orignal_ != SDL_BLENDMODE_NONE) {
			SDL_SetSurfaceBlendMode(surf, SDL_BLENDMODE_NONE);
		}
	}
	~tblend_none_lock()
	{
		if (orignal_ != SDL_BLENDMODE_NONE) {
			SDL_SetSurfaceBlendMode(surf_, orignal_);
		}
	}

private:
	surface& surf_;
	SDL_BlendMode orignal_;
};

namespace {

/*WIKI
 * @page = GUICanvasWML
 *
 * {{Autogenerated}}
 *
 * = Canvas =
 *
 * A canvas is a blank drawing area on which the user can draw several shapes.
 * The drawing is done by adding WML structures to the canvas.
 */

/*WIKI
 * @page = GUICanvasWML
 * @begin{parent}{name="generic/state/draw/"}
 *
 * == Pre commit ==
 * @begin{tag}{name="pre_commit"}{min="0"}{max="1"}
 *
 * This section contains the pre commit functions. These functions will be
 * executed before the drawn canvas is applied on top of the normal
 * background. There should only be one pre commit section and its order
 * regarding the other shapes doesn't matter. The function has effect on the
 * entire canvas, it's not possible to affect only a small part of the canvas.
 *
 * The section can have one of the following subsections.
 *
 * === Blur ===
 * @begin{tag}{name="blur"}{min="0"}{max="1"}
 *
 * Blurs the background before applying the canvas. This doesn't make sense
 * if the widget isn't semi-transparent.
 *
 * Keys:
 * @begin{table}{config}
 *     depth & unsigned & 0 &            The depth to blur. $
 * @end{table}
 * @end{tag}{name="blur"}
 * @end{tag}{name="pre_commit"}
 */

/***** ***** ***** ***** ***** LINE ***** ***** ***** ***** *****/

/** Definition of a line shape. */
class tline
	: public tcanvas::tshape
{
public:

	/**
	 * Constructor.
	 *
	 * @param cfg                 The config object to define the line see
	 *                            http://www.wesnoth.org/wiki/GUICanvasWML#Line
	 *                            for more information.
	 */
	explicit tline(const config& cfg);

	/** Implement shape::draw(). */
	void draw(surface& canvas
			, const game_logic::map_formula_callable& variables);

private:
	tformula<unsigned>
		x1_, /**< The start x coordinate of the line. */
		y1_, /**< The start y coordinate of the line. */
		x2_, /**< The end x coordinate of the line. */
		y2_; /**< The end y coordinate of the line. */

	/** The color of the line. */
	Uint32 color_;

	std::string color_str_;

	enum {hdpi_x1, hdpi_y1, hdpi_x2, hdpi_y2, hdpi_count};
	bool hdpi_off_[hdpi_count];
};

tline::tline(const config& cfg)
	: x1_(cfg["x1"])
	, y1_(cfg["y1"])
	, x2_(cfg["x2"])
	, y2_(cfg["y2"])
	, color_(decode_color(cfg["color"]))
	, color_str_(cfg["color"])
{
/*WIKI
 * @page = GUICanvasWML
 *
 * == Line ==
 * @begin{tag}{name="line"}{min="0"}{max="-1"}
 * Definition of a line. When drawing a line it doesn't get blended on the
 * surface but replaces the pixels instead. A blitting flag might be added later
 * if needed.
 *
 * Keys:
 * @begin{table}{config}
 *     x1 & f_unsigned & 0 &           The x coordinate of the startpoint. $
 *     y1 & f_unsigned & 0 &           The y coordinate of the startpoint. $
 *     x2 & f_unsigned & 0 &           The x coordinate of the endpoint. $
 *     y2 & f_unsigned & 0 &           The y coordinate of the endpoint. $
 *     color & color & "" &            The color of the line. $
 *     thickness & unsigned & 0 &      The thickness of the line if 0 nothing
 *                                     is drawn. $
 *     debug & string & "" &           Debug message to show upon creation
 *                                     this message is not stored. $
 * @end{table}
 * @end{tag}{name="line"}
 *
 * <span id="general_variables">Variables:</span>.
 * @begin{table}{formula}
 *     width & unsigned &                 The width of the canvas. $
 *     height & unsigned &                The height of the canvas. $
 *     text & tstring &                   The text to render on the widget. $
 *     text_maximum_width & unsigned &    The maximum width available for the text
 *                                        on the widget. $
 *     text_maximum_height & unsigned &   The maximum height available for the text
 *                                        on the widget. $
 *     text_wrap_mode & int  &            When the text doesn't fit in the
 *                                        available width there are several ways
 *                                        to fix that. This variable holds the
 *                                        best method. (NOTE this is a 'hidden'
 *                                        variable meant to copy state from a
 *                                        widget to its canvas so there's no
 *                                        reason to use this variable and thus
 *                                        its values are not listed and might
 *                                        change without further notice.) $
 *     text_alignment & h_align &         The way the text is aligned inside the
 *                                        canvas. $
 *@end{table}
 *
 * The size variables are copied to the window and will be determined at
 * runtime. This is needed since the main window can be resized and the dialog
 * needs to resize accordingly. The following variables are available:
 * @begin{table}{formula}
 *     screen_width & unsigned &        The usable width of the Wesnoth main
 *                                      window. $
 *     screen_height & unsigned &       The usable height of the Wesnoth main
 *                                      window. $
 *     gamemap_width & unsigned &       The usable width of the Wesnoth gamemap,
 *                                      if no gamemap shown it's the same value as
 *                                      screen_width. $
 *     gamemap_height & unsigned &      The usable height of the Wesnoth gamemap,
 *                                      if no gamemap shown it's the same value as
 *                                      screen_height. $
 * @end{table}
 *
 * Note when drawing the valid coordinates are:<br>
 * 0 -> width - 1 <br>
 * 0 -> height -1
 *
 * Drawing outside this area will result in unpredictable results including
 * crashing. (That should be fixed, when encountered.)
 */

/*WIKI - unclassified
 * This code can be used by a parser to generate the wiki page
 * structure
 * [tag name]
 * param type_info description
 *
 * param                               Name of the parameter.
 *
 * type_info = ( type = default_value) The info about a optional parameter.
 * type_info = ( type )                The info about a mandatory parameter
 * type_info = [ type_info ]           The info about a conditional parameter
 *                                     description should explain the reason.
 *
 * description                         Description of the parameter.
 *
 *
 *
 *
 * Formulas are a function between brackets, that way the engine can see whether
 * there is standing a plain number or a formula eg:
 * 0     A value of zero
 * (0)   A formula returning zero
 *
 * When formulas are available the text should state the available variables
 * which are available in that function.
 */

/*WIKI
 * @page = GUIVariable
 *
 * {{Autogenerated}}
 *
 * = Variables =
 *
 * In various parts of the GUI there are several variables types in use. This
 * page describes them.
 *
 * == Simple types ==
 *
 * The simple types are types which have one value or a short list of options.
 *
 * @begin{table}{variable_types}
 *     unsigned &                      Unsigned number (positive whole numbers
 *                                     and zero). $
 *     f_unsigned &                    Unsigned number or formula returning an
 *                                     unsigned number. $
 *     int &                           Signed number (whole numbers). $
 *     f_int &                         Signed number or formula returning an
 *                                     signed number. $
 *     bool &                          A boolean value accepts the normal
 *                                     values as the rest of the game. $
 *     f_bool &                        Boolean value or a formula returning a
 *                                     boolean value. $
 *     string &                        A text. $
 *     tstring &                       A translatable string. $
 *     f_tstring &                     Formula returning a translatable string. $
 *
 *     color &                         A string which contains the color, this
 *                                     a group of 4 numbers between 0 and 255
 *                                     separated by a comma. The numbers are red
 *                                     component, green component, blue
 *                                     component and alpha. A color of 0 is not
 *                                     available. An alpha of 255 is fully
 *                                     transparent. Omitted values are set to 0. $
 *
 *     font_style &                    A string which contains the style of the
 *                                     font:
 *                                     @* normal    normal font
 *                                     @* bold      bold font
 *                                     @* italic    italic font
 *                                     @* underline underlined font
 *                                     @-Since SDL has problems combining these
 *                                     styles only one can be picked. Once SDL
 *                                     will allow multiple options, this type
 *                                     will be transformed to a comma separated
 *                                     list. If empty we default to the normal
 *                                     style. Since the render engine is
 *                                     replaced by Pango markup this field will
 *                                     change later on. Note widgets that allow
 *                                     marked up text can use markup to change
 *                                     the font style. $
 *
 *     v_align &                       Vertical alignment; how an item is
 *                                     aligned vertically in the available
 *                                     space. Possible values:
 *                                     @* top    aligned at the top
 *                                     @* bottom aligned at the bottom
 *                                     @* center centered
 *                                     @-When nothing is set or an another
 *                                     value as in the list the item is
 *                                     centered. $
 *
 *     h_align &                       Horizontal alignment; how an item is
 *                                     aligned horizontal in the available
 *                                     space. Possible values:
 *                                     @* left   aligned at the left side
 *                                     @* right  aligned at the right side
 *                                     @* center centered $
 *
 *     f_h_align &                     A horizontal alignment or a formula
 *                                     returning a horizontal alignment. $
 *
 *     border &                        Comma separated list of borders to use.
 *                                     Possible values:
 *                                     @* left   border at the left side
 *                                     @* right  border at the right side
 *                                     @* top    border at the top
 *                                     @* bottom border at the bottom
 *                                     @* all    alias for "left, right, top,
 *                                     bottom" $
 *
 *     scrollbar_mode &                How to show the scrollbar of a widget.
 *                                     Possible values:
 *                                     @* always       The scrollbar is always
 *                                     shown, regardless whether it's required
 *                                     or not.
 *                                     @* never        The scrollbar is never
 *                                     shown, even not when needed. (Note when
 *                                     setting this mode dialogs might
 *                                     not properly fit anymore).
 *                                     @* auto         Shows the scrollbar when
 *                                     needed. The widget will reserve space for
 *                                     the scrollbar, but only show when needed.
 *                                     @* initial_auto Like auto, but when the
 *                                     scrollbar is not needed the space is not
 *                                     reserved.
 *                                     @-Use auto when the list can be changed
 *                                     dynamically eg the game list in the
 *                                     lobby. For optimization you can also
 *                                     use auto when you really expect a
 *                                     scrollbar, but don't want it to be shown
 *                                     when not needed eg the language list
 *                                     will need a scrollbar on most screens. $
 *
 *     resize_mode &                   Determines how an image is resized.
 *                                     Possible values:
 *                                     @* scale        The image is scaled.
 *                                     @* stretch      The first row or column
 *                                     of pixels is copied over the entire
 *                                     image. (Can only be used to scale resize
 *                                     in one direction, else falls
 *                                     back to scale.)
 *                                     @* tile         The image is placed
 *                                     several times until the entire surface
 *                                     is filled. The last images are
 *                                     truncated. $
 *
 *     grow_direction &                Determines how an image is resized.
 *                                     Possible values:
 *                                     @* scale        The image is scaled.
 *                                     @* stretch      The first row or column
 *                                     of pixels is copied over the entire
 *                                     image. (Can only be used to scale resize
 *                                     in one direction, else falls
 *                                     back to scale.)
 *                                     @* tile         The image is placed
 *                                     several times until the entire surface
 *                                     is filled. The last images are
 *                                     truncated. $
 * @end{table}
 * @allow{type}{name="unsigned"}{value="^\d+$"}
 * @allow{type}{name="f_unsigned"}{value="^.+$"}
 * @allow{type}{name="int"}{value="^-?\d+$"}
 * @allow{type}{name="f_int"}{value="^.*$"}
 * @allow{type}{name="bool"}{value="^true|false|yes|no$"}
 * @allow{type}{name="f_bool"}{value="^.*$"}
 * @allow{type}{name="string"}{value="^.*$"}
 * @allow{type}{name="t_string"}{value="^_?.*$"}
 * @allow{type}{name="f_string"}{value="^.*$"}
 * @allow{type}{name="f_tstring"}{value="^_?.*$"}
 *
 * @allow{type}{name="color"}{value="^(?:2[0-5][0-5]|[01]?\d?\d)[.,]\s*(?:2[0-5][0-5]|[01]?\d?\d)[.,]\s*(?:2[0-5][0-5]|[01]?\d?\d)[.,]\s*(?:2[0-5][0-5]|[01]?\d?\d)$"}
 *
 * @allow{type}{name="font_style"}{value="^(normal|bold|italic|underline)?$"}
 * @allow{type}{name="v_align"}{value="^top|bottom|center$"}
 * @allow{type}{name="h_align"}{value="^left|right|center$"}
 * @allow{type}{name="f_h_align"}{value="^.*$"}
 * @allow{type}{name="border"}{value="^(top|bottom|left|right|all)?(,\s*(top|bottom|left|right|all))*$"}
 * @allow{type}{name="scrollbar_mode"}{value="^always|never|auto|initial_auto$"}
 * @allow{type}{name="resize_mode"}{value="^scale|stretch|tile$"}
 * @allow{type}{name="grow_direction"}{value="^horizontal|vertical$"}
 *
 * @remove{type}{name="section"}
 * @remove{type}{name="config"}
 * @remove{type}{name="grid"}
 * == Section types ==
 *
 * For more complex parts, there are sections. Sections contain of several
 * lines of WML and can have sub sections. For example a grid has sub sections
 * which contain various widgets. Here's the list of sections.
 *
 * @begin{table}{variable_types}
 *     section &                       A generic section. The documentation
 *                                     about the section should describe the
 *                                     section in further detail. $
 *
 *     grid &                          A grid contains several widgets. (TODO
 *                                     add link to generic grid page.) $
 * @end{table}
 */

	decode_hdpi_off(cfg["hdpi_off"].str(), hdpi_count, hdpi_off_);
}

void tline::draw(surface& canvas, const game_logic::map_formula_callable& variables)
{
	if (color_ == MAGIC_COLOR) {
		tformula<unsigned> f(color_str_);
		color_ = f(variables);
	}

	/**
	 * @todo formulas are now recalculated every draw cycle which is a bit silly
	 * unless there has been a resize. So to optimize we should use an extra
	 * flag or do the calculation in a separate routine.
	 */
	const unsigned x1 = x1_(variables) * (hdpi_off_[hdpi_x1]? 1: twidget::hdpi_scale);
	const unsigned y1 = y1_(variables) * (hdpi_off_[hdpi_y1]? 1: twidget::hdpi_scale);
	const unsigned x2 = x2_(variables) * (hdpi_off_[hdpi_x2]? 1: twidget::hdpi_scale);
	const unsigned y2 = y2_(variables) * (hdpi_off_[hdpi_y2]? 1: twidget::hdpi_scale);

	VALIDATE(
			  static_cast<int>(x1) < canvas->w
				&& static_cast<int>(x2) < canvas->w
				&& static_cast<int>(y1) < canvas->h
				&& static_cast<int>(y2) < canvas->h
			, _("Line doesn't fit on canvas."));

	if (x1 == x2 && y1 == y2) {
		return;
	}

	// @todo FIXME respect the thickness.

	// now draw the line we use Bresenham's algorithm, which doesn't
	// support antialiasing. The advantage is that it's easy for testing.

	// lock the surface
	surface_lock locker(canvas);
	if (x1 > x2) {
		// invert points
		draw_line(canvas, color_, x2, y2, x1, y1, true);
	} else {
		draw_line(canvas, color_, x1, y1, x2, y2, true);
	}
}

/***** ***** ***** ***** ***** Rectangle ***** ***** ***** ***** *****/

/** Definition of a rectangle shape. */
class trectangle
	: public tcanvas::tshape
{
public:

	/**
	 * Constructor.
	 *
	 * @param cfg                 The config object to define the rectangle see
	 *                            http://www.wesnoth.org/wiki/GUICanvasWML#Rectangle
	 *                            for more information.
	 */
	explicit trectangle(const config& cfg);

	/** Implement shape::draw(). */
	void draw(surface& canvas
			, const game_logic::map_formula_callable& variables);

private:
	tformula<unsigned>
		x_, /**< The x coordinate of the rectangle. */
		y_, /**< The y coordinate of the rectangle. */
		w_, /**< The width of the rectangle. */
		h_; /**< The height of the rectangle. */

	/**
	 * Border thickness.
	 *
	 * If 0 the fill color is used for the entire widget.
	 */
	unsigned border_thickness_;

	/**
	 * The border color of the rectangle.
	 *
	 * If the color is fully transparent the border isn't drawn.
	 */
	Uint32 border_color_;

	/**
	 * The border color of the rectangle.
	 *
	 * If the color is fully transparent the rectangle won't be filled.
	 */
	Uint32 fill_color_;

	enum {hdpi_x, hdpi_y, hdpi_w, hdpi_h, hdpi_thickness, hdpi_count};
	bool hdpi_off_[hdpi_count];
};

trectangle::trectangle(const config& cfg)
	: x_(cfg["x"])
	, y_(cfg["y"])
	, w_(cfg["w"])
	, h_(cfg["h"])
	, border_thickness_(cfg["border_thickness"])
	, border_color_(decode_color(cfg["border_color"]))
	, fill_color_(decode_color(cfg["fill_color"]))
{
/*WIKI
 * @page = GUICanvasWML
 *
 * == Rectangle ==
 * @begin{tag}{name="rectangle"}{min="0"}{max="-1"}
 *
 * Definition of a rectangle. When drawing a rectangle it doesn't get blended on
 * the surface but replaces the pixels instead. A blitting flag might be added
 * later if needed.
 *
 * Keys:
 * @begin{table}{config}
 *     x & f_unsigned & 0 &            The x coordinate of the top left corner. $
 *     y & f_unsigned & 0 &            The y coordinate of the top left corner. $
 *     w & f_unsigned & 0 &            The width of the rectangle. $
 *     h & f_unsigned & 0 &            The height of the rectangle. $
 *     border_thickness & unsigned & 0 &
 *                                     The thickness of the border if the
 *                                     thickness is zero it's not drawn. $
 *     border_color & color & "" &     The color of the border if empty it's
 *                                     not drawn. $
 *     fill_color & color & "" &       The color of the interior if omitted
 *                                     it's not drawn. $
 *     debug & string & "" &           Debug message to show upon creation
 *                                     this message is not stored. $
 * @end{table}
 * @end{tag}{name="rectangle"}
 * Variables:
 * See [[#general_variables|Line]].
 *
 */
	decode_hdpi_off(cfg["hdpi_off"].str(), hdpi_count, hdpi_off_);

	if (border_color_ == 0) {
		border_thickness_ = 0;
	}
	border_thickness_ *= (hdpi_off_[hdpi_thickness]? 1: twidget::hdpi_scale);
}

void trectangle::draw(surface& canvas
		, const game_logic::map_formula_callable& variables)
{
	/**
	 * @todo formulas are now recalculated every draw cycle which is a  bit
	 * silly unless there has been a resize. So to optimize we should use an
	 * extra flag or do the calculation in a separate routine.
	 */
	const unsigned x = x_(variables) * (hdpi_off_[hdpi_x]? 1: twidget::hdpi_scale);
	const unsigned y = y_(variables) * (hdpi_off_[hdpi_y]? 1: twidget::hdpi_scale);
	const unsigned w = w_(variables) * (hdpi_off_[hdpi_w]? 1: twidget::hdpi_scale);
	const unsigned h = h_(variables) * (hdpi_off_[hdpi_h]? 1: twidget::hdpi_scale);

	if (!w || !h) {
		return;
	}

	VALIDATE(
			  static_cast<int>(x) < canvas->w
				&& static_cast<int>(x + w) <= canvas->w
				&& static_cast<int>(y) < canvas->h
				&& static_cast<int>(y + h) <= canvas->h
			, _("Rectangle doesn't fit on canvas."));


	surface_lock locker(canvas);

	// draw the border
	for(unsigned i = 0; i < border_thickness_; ++i) {

		const unsigned left = x + i;
		const unsigned right = left + w - (i * 2) - 1;
		const unsigned top = y + i;
		const unsigned bottom = top + h - (i * 2) - 1;

		// top horizontal (left -> right)
		draw_line(canvas, border_color_, left, top, right, top, true);

		// right vertical (top -> bottom)
		draw_line(canvas, border_color_, right, top, right, bottom, true);

		// bottom horizontal (left -> right)
		draw_line(canvas, border_color_, left, bottom, right, bottom, true);

		// left vertical (top -> bottom)
		draw_line(canvas, border_color_, left, top, left, bottom, true);
	}

	// The fill_rect_alpha code below fails, can't remember the exact cause
	// so use the slow line drawing method to fill the rect.
	if(fill_color_) {

		const unsigned left = x + border_thickness_;
		const unsigned right = left + w - (2 * border_thickness_) - 1;
		const unsigned top = y + border_thickness_;
		const unsigned bottom = top + h - (2 * border_thickness_);

		for(unsigned i = top; i < bottom; ++i) {

			draw_line(canvas, fill_color_, left, i, right, i, true);
		}
	}
}

/***** ***** ***** ***** ***** CIRCLE ***** ***** ***** ***** *****/

/** Definition of a circle shape. */
class tcircle
	: public tcanvas::tshape
{
public:

	/**
	 * Constructor.
	 *
	 * @param cfg                 The config object to define the circle see
	 *                            http://www.wesnoth.org/wiki/GUICanvasWML#Circle
	 *                            for more information.
	 */
	explicit tcircle(const config& cfg);

	/** Implement shape::draw(). */
	void draw(surface& canvas
			, const game_logic::map_formula_callable& variables);

private:
	tformula<unsigned>
		x_,       /**< The centre x coordinate of the circle. */
		y_,       /**< The centre y coordinate of the circle. */
		radius_;  /**< The radius of the circle. */

	/** The color of the circle. */
	Uint32 color_;

};

tcircle::tcircle(const config& cfg)
	: x_(cfg["x"])
	, y_(cfg["y"])
	, radius_(cfg["radius"])
	, color_(decode_color(cfg["color"]))
{
/*WIKI
 * @page = GUICanvasWML
 *
 * == Circle ==
 * @begin{tag}{name="circle"}{min="0"}{max="-1"}
 *
 * Definition of a circle. When drawing a circle it doesn't get blended on
 * the surface but replaces the pixels instead. A blitting flag might be
 * added later if needed.
 *
 * Keys:
 * @begin{table}{config}
 * x      & f_unsigned & 0 &       The x coordinate of the centre. $
 * y      & f_unsigned & 0 &       The y coordinate of the centre. $
 * radius & f_unsigned & 0 &       The radius of the circle if 0 nothing is
 *                                 drawn. $
 * color & color & "" &            The color of the circle. $
 * debug & string & "" &           Debug message to show upon creation this
 *                                 message is not stored. $
 * @end{table}
 * @end{tag}{name="circle"}
 * Variables:
 * See [[#general_variables|Line]].
 *
 * Drawing outside the area will result in unpredictable results including
 * crashing. (That should be fixed, when encountered.)
 */

	const std::string& debug = (cfg["debug"]);
	if(!debug.empty()) {
		DBG_GUI_P << "Circle: found debug message '" << debug << "'.\n";
	}
}

void tcircle::draw(surface& canvas
		, const game_logic::map_formula_callable& variables)
{
	/**
	 * @todo formulas are now recalculated every draw cycle which is a bit
	 * silly unless there has been a resize. So to optimize we should use an
	 * extra flag or do the calculation in a separate routine.
	 */

	const unsigned x = x_(variables);
	const unsigned y = y_(variables);
	const unsigned radius = radius_(variables);

	VALIDATE_WITH_DEV_MESSAGE(
			 static_cast<int>(x - radius) >= 0
			, _("Circle doesn't fit on canvas.")
			, (formatter() << "x = " << x << ", radius = " << radius).str());

	VALIDATE_WITH_DEV_MESSAGE(
			 static_cast<int>(y - radius) >= 0
			, _("Circle doesn't fit on canvas.")
			, (formatter() << "y = " << y << ", radius = " << radius).str());

	VALIDATE_WITH_DEV_MESSAGE(
			 static_cast<int>(x + radius) < canvas->w
			, _("Circle doesn't fit on canvas.")
			, (formatter() << "x = " << x << ", radius = " << radius
				<< "', canvas width = " << canvas->w << ".").str());

	VALIDATE_WITH_DEV_MESSAGE(
			 static_cast<int>(y + radius) < canvas->h
			, _("Circle doesn't fit on canvas.")
			, (formatter() << "y = " << y << ", radius = " << radius
				<< "', canvas height = " << canvas->h << ".").str());

	// lock the surface
	surface_lock locker(canvas);
	draw_circle(canvas, color_, x, y, radius, true);
}

/***** ***** ***** ***** ***** IMAGE ***** ***** ***** ***** *****/

/** Definition of an image shape. */
class timage
	: public tcanvas::tshape
{
public:
	/**
	 * Constructor.
	 *
	 * @param cfg                 The config object to define the image see
	 *                            http://www.wesnoth.org/wiki/GUICanvasWML#Image
	 *                            for more infomation.
	 */
	explicit timage(const config& cfg);

	/** Implement shape::draw(). */
	void draw(surface& canvas
			, const game_logic::map_formula_callable& variables);

private:
	tformula<unsigned>
		x_, /**< The x coordinate of the image. */
		y_, /**< The y coordinate of the image. */
		w_, /**< The width of the image. */
		h_; /**< The height of the image. */

	/** Contains the size of the image. */
	SDL_Rect src_clip_;

	/** The image is cached in this surface. */
	surface image_;



	/**
	 * Name of the image.
	 *
	 * This value is only used when the image name is a formula. If it isn't a
	 * formula the image will be loaded in the constructor. If it's a formula it
	 * will be loaded every draw cycles. This allows 'changing' images.
	 */
	tformula<std::string> image_name_;

	/**
	 * Determines the way an image will be resized.
	 *
	 * If the image is smaller is needed it needs to resized, how is determined
	 * by the value of this enum.
	 */
	enum tresize_mode {
		  scale
		, stretch
		, tile
	};

	/** Converts a string to a resize mode. */
	tresize_mode get_resize_mode(const std::string& resize_mode);

	/** The resize mode for an image. */
	tresize_mode resize_mode_;

	/** Mirror the image over the vertical axis. */
	tformula<bool> vertical_mirror_;

	enum {hdpi_x, hdpi_y, hdpi_w, hdpi_h, hdpi_count};
	bool hdpi_off_[hdpi_count];
};

timage::timage(const config& cfg)
	: x_(cfg["x"])
	, y_(cfg["y"])
	, w_(cfg["w"])
	, h_(cfg["h"])
	, src_clip_()
	, image_()
	, image_name_(cfg["name"])
	, resize_mode_(get_resize_mode(cfg["resize_mode"]))
	, vertical_mirror_(cfg["vertical_mirror"])
{
/*WIKI
 * @page = GUICanvasWML
 *
 * == Image ==
 * @begin{tag}{name="image"}{min="0"}{max="-1"}
 * Definition of an image.
 *
 * Keys:
 * @begin{table}{config}
 *     x & f_unsigned & 0 &            The x coordinate of the top left corner. $
 *     y & f_unsigned & 0 &            The y coordinate of the top left corner. $
 *     w & f_unsigned & 0 &            The width of the image, if not zero the
 *                                     image will be scaled to the desired
 *                                     width. $
 *     h & f_unsigned & 0 &            The height of the image, if not zero the
 *                                     image will be scaled to the desired
 *                                     height. $
 *     resize_mode & resize_mode & scale &
 *                                     Determines how an image is scaled to fit
 *                                     the wanted size. $
 *     vertical_mirror & f_bool & false &
 *                                     Mirror the image over the vertical axis. $
 *     name & f_string & "" &          The name of the image. $
 *     debug & string & "" &           Debug message to show upon creation
 *                                     this message is not stored. $
 *
 * @end{table}
 * @end{tag}{name="image"}
 * Variables:
 * @begin{table}{formula}
 *     image_width & unsigned &         The width of the image, either the
 *                                      requested width or the natural width of
 *                                      the image. This value can be used to set
 *                                      the x (or y) value of the image. (This
 *                                      means x and y are evaluated after the
 *                                      width and height.) $
 *     image_height & unsigned &        The height of the image, either the
 *                                      requested height or the natural height
 *                                      of the image. This value can be used to
 *                                      set the y (or x) value of the image.
 *                                      (This means x and y are evaluated after
 *                                      the width and height.) $
 *     image_original_width & unsigned &
 *                                      The width of the image as stored on
 *                                      disk, can be used to set x or w
 *                                      (also y and h can be set). $
 *     image_original_height & unsigned &
 *                                      The height of the image as stored on
 *                                      disk, can be used to set y or h
 *                                      (also x and y can be set). $
 * @end{table}
 * Also the general variables are available, see [[#general_variables|Line]].
 */
	decode_hdpi_off(cfg["hdpi_off"].str(), hdpi_count, hdpi_off_);
}

const std::string share_image_name = "share";

void timage::draw(surface& canvas, const game_logic::map_formula_callable& variables)
{
	/**
	 * @todo formulas are now recalculated every draw cycle which is a  bit
	 * silly unless there has been a resize. So to optimize we should use an
	 * extra flag or do the calculation in a separate routine.
	 */
	std::string name = image_name_(variables);
	if (name.empty()) {
		return;
	}

	if (name.find("misc/dir.png") != std::string::npos) {
		int ii = 0;
	}

	bool from_share = false;
	/*
	 * The locator might return a different surface for every call so we can't
	 * cache the output, also not if no formula is used.
	 */
	if (name != share_image_name || !share_canvas_image || share_canvas_image->null()) {
		surface tmp;
		if (twidget::hdpi_scale > 1) {
			tmp = image::get_image(image::locator(get_hdpi_name(name, twidget::hdpi_scale)));
		}
		if (!tmp) {
			tmp = image::get_image(image::locator(name));
		}
		if (!tmp) {
			return;
		}
		image_ = tmp;
	} else {
		from_share = true;
		// to share image, must set width/height to original size. so cannot change share_canvas_image.
		image_ = *share_canvas_image;
	}
	src_clip_ = ::create_rect(0, 0, image_->w, image_->h);

	game_logic::map_formula_callable local_variables(variables);
	local_variables.add("image_original_width", variant(image_->w));
	local_variables.add("image_original_height", variant(image_->h));

	unsigned w = w_(local_variables);
	VALIDATE_WITH_DEV_MESSAGE(
			  static_cast<int>(w) >= 0
			, _("Image doesn't fit on canvas.")
			, (formatter() << "Image '" << name
				<< "', w = " << static_cast<int>(w) << ".").str());

	unsigned h = h_(local_variables);
	VALIDATE_WITH_DEV_MESSAGE(
			  static_cast<int>(h) >= 0
			, _("Image doesn't fit on canvas.")
			, (formatter() << "Image '" << name
				<< "', h = " << static_cast<int>(h) << ".").str());

	VALIDATE(!from_share || (image_->w == w && image_->h == h), "share image's width and height must be original size!");

	if ((!w && w_.has_formula()) || (!h && h_.has_formula())) { 
		return;
	}

	const unsigned x = x_(local_variables) * (hdpi_off_[hdpi_x]? 1: twidget::hdpi_scale);
	VALIDATE_WITH_DEV_MESSAGE(
			  static_cast<int>(x) >= 0
			, _("Image doesn't fit on canvas.")
			, (formatter() << "Image '" << name
				<< "', x = " << static_cast<int>(x) << ".").str());

	const unsigned y = y_(local_variables) * (hdpi_off_[hdpi_y]? 1: twidget::hdpi_scale);
	VALIDATE_WITH_DEV_MESSAGE(
			  static_cast<int>(y) >= 0
			, _("Image doesn't fit on canvas.")
			, (formatter() << "Image '" << name
				<< "', y = " << static_cast<int>(y) << ".").str());


	// Copy the data to local variables to avoid overwriting the originals.
	SDL_Rect src_clip = src_clip_;
	SDL_Rect dst_clip = ::create_rect(x, y, 0, 0);
	surface surf;

	// Test whether we need to scale and do the scaling if needed.
	if (w || h) {
		bool done = false;
		bool stretch_image = (resize_mode_ == stretch) && (!!w ^ !!h);

		w *= hdpi_off_[hdpi_w]? 1: twidget::hdpi_scale;
		h *= hdpi_off_[hdpi_h]? 1: twidget::hdpi_scale;

		if (!w) {
			// if w = 0, think use image_original_width. don't conside hdpi_scale.
			if (stretch_image) {
				// Image: vertical stretch from image_->w, image_->h to a height of h.
				surf = stretch_surface_vertical(image_, h, false);
				done = true;
			}
			w = image_->w;
		}

		if (!h) {
			// if h = 0, think use image_original_height. don't conside hdpi_scale.
			if (stretch_image) {
				// Image: horizontal stretch from image_->w, image_->h to a width of w.
				surf = stretch_surface_horizontal(image_, w, false);
				done = true;
			}
			h = image_->h;
		}

		if (!done) {
			if (resize_mode_ == tile) {
				// Image: tiling from image_->w, image_->h to w, h.
				const int columns = (w + image_->w - 1) / image_->w;
				const int rows = (h + image_->h - 1) / image_->h;
				surf = create_neutral_surface(w, h);

				for (int x = 0; x < columns; ++x) {
					for (int y = 0; y < rows; ++y) {
						SDL_Rect dest = ::create_rect(
								  x * image_->w
								, y * image_->h
								, 0
								, 0);
						sdl_blit(image_, NULL, surf, &dest);
					}
				}

			} else {
				// Image: scaling from image_->w, image_->h to w, h.;
				surf = scale_surface(image_, w, h, false);
			}
		}
		src_clip.w = w;
		src_clip.h = h;
	} else {
		if (hdpi_off_[hdpi_w] || hdpi_off_[hdpi_h]) {
			src_clip.w *= hdpi_off_[hdpi_w]? 1: twidget::hdpi_scale;
			src_clip.h *= hdpi_off_[hdpi_h]? 1: twidget::hdpi_scale;
			surf = scale_surface(image_, src_clip.w, src_clip.h, false);
		} else {
			surf = image_;
		}
	}

	if (vertical_mirror_(local_variables)) {
		surf = flip_surface(surf, false);
	}

	// tblend_none_lock lock(surf);

	sdl_blit(surf, &src_clip, canvas, &dst_clip);
}

timage::tresize_mode timage::get_resize_mode(const std::string& resize_mode)
{
	if(resize_mode == "tile") {
		return timage::tile;
	} else if(resize_mode == "stretch") {
		return timage::stretch;
	} else {
		if(!resize_mode.empty() && resize_mode != "scale") {
			ERR_GUI_E << "Invalid resize mode '"
					<< resize_mode << "' falling back to 'scale'.\n";
		}
		return timage::scale;
	}
}

/***** ***** ***** ***** ***** TEXT ***** ***** ***** ***** *****/

/** Definition of a text shape. */
class ttext
	: public tcanvas::tshape
{
public:

	/**
	 * Constructor.
	 *
	 * @param cfg                 The config object to define the text see
	 *                            http://www.wesnoth.org/wiki/GUICanvasWML#Text
	 *                            for more information.
	 */
	explicit ttext(const config& cfg);

	/** Implement shape::draw(). */
	void draw(surface& canvas
			, const game_logic::map_formula_callable& variables);

private:
	tformula<unsigned>
		x_, /**< The x coordinate of the text. */
		y_, /**< The y coordinate of the text. */
		w_, /**< The width of the text. */
		h_; /**< The height of the text. */

	/** The font size of the text. */
	unsigned font_size_;

	/** The style of the text. */
	unsigned font_style_;

	/** The alignment of the text. */
	tformula<PangoAlignment> text_alignment_;

	/** The color of the text. */
	Uint32 color_;

	std::string color_str_;

	/** The text to draw. */
	tformula<t_string> text_;

	/** The read only switch of the text. */
	tformula<bool> editable_;

	/** The maximum width for the text. */
	tformula<int> maximum_width_;

	enum {hdpi_x, hdpi_y, hdpi_count};
	bool hdpi_off_[hdpi_count];
};

ttext::ttext(const config& cfg)
	: x_(cfg["x"])
	, y_(cfg["y"])
	, w_(cfg["w"])
	, h_(cfg["h"])
	, font_size_(cfg["font_size"].to_int())
	, font_style_(decode_font_style(cfg["font_style"]))
	, text_alignment_(cfg["text_alignment"])
	, color_(decode_color(cfg["color"]))
	, color_str_(cfg["color"])
	, text_(cfg["text"])
	, editable_(cfg["editable"], false)
	, maximum_width_(cfg["maximum_width"], -1)
{

/*WIKI
 * @page = GUICanvasWML
 *
 * == Text ==
 * @begin{tag}{name="text"}{min="0"}{max="-1"}
 * Definition of text.
 *
 * Keys:
 * @begin{table}{config}
 *     x & f_unsigned & 0 &            The x coordinate of the top left corner. $
 *     y & f_unsigned & 0 &            The y coordinate of the top left corner. $
 *     w & f_unsigned & 0 &            The width of the text's bounding
 *                                     rectangle. $
 *     h & f_unsigned & 0 &            The height of the text's bounding
 *                                     rectangle. $
 *     font_size & unsigned & &        The size of the text font. $
 *     font_style & font_style & "" &  The style of the text. $
 *     text_alignment & f_h_align & "left" &
 *                                     The alignment of the text. $
 *     color & color & "" &            The color of the text. $
 *     text & f_tstring & "" &         The text to draw (translatable). $
 *     text_markup & f_bool & false &  Can the text have mark-up? $
 *     maximum_width & f_int & -1 &    The maximum width the text is allowed to
 *                                     be. $
 *     maximum_height & f_int & -1 &   The maximum height the text is allowed
 *                                     to be. $
 *     debug & string & "" &           Debug message to show upon creation
 *                                     this message is not stored. $
 * @end{table}
 * @end{tag}{name="text"}
 * NOTE alignment could only be done with the formulas, but now with the
 * text_alignment flag as well, older widgets might still use the formulas and
 * not all widgets may expose the text alignment yet and when exposed not use
 * it yet.
 *
 * Variables:
 * @begin{table}{formula}
 *     text_width & unsigned &            The width of the rendered text. $
 *     text_height & unsigned &           The height of the rendered text. $
 * @end{table}
 * Also the general variables are available, see [[#general_variables|Line]].
 * @end{parent}{name="generic/state/draw/"}
 */

	VALIDATE(font_size_, _("Text has a font size of 0."));
	font_size_ *= twidget::hdpi_scale;

	decode_hdpi_off(cfg["hdpi_off"].str(), hdpi_count, hdpi_off_);
}

void ttext::draw(surface& canvas, const game_logic::map_formula_callable& variables)
{
	if (color_ == MAGIC_COLOR) {
		tformula<unsigned> f(color_str_);
		color_ = f(variables);
	}

	VALIDATE(variables.has_key("text"), null_str);

	// We first need to determine the size of the text which need the rendered
	// text. So resolve and render the text first and then start to resolve
	// the other formulas.
	const std::string text = text_(variables);

	if (text.empty()) {
		// Text: no text to render, leave.
		return;
	}

	if (text.find("1.0.2") != std::string::npos) {
		int ii = 0;
	}

	surface surf;
	if (!share_canvas_integrate) {
		const int maximum_width = maximum_width_(variables) * twidget::hdpi_scale;
		bool text_editable = editable_(variables);
		surf = font::get_rendered_text2(text, maximum_width, font_size_, int_to_color(color_ >> 8), text_editable);
	} else {
		surf = share_canvas_integrate->get_surface();
	}

	if (surf->w == 0) {
		// Text: Rendering, resulted in an empty canvas, leave.
		return;
	}

	game_logic::map_formula_callable local_variables(variables);
	local_variables.add("text_width", variant(surf->w / twidget::hdpi_scale));
	local_variables.add("text_height", variant(surf->h / twidget::hdpi_scale));

	// @todo formulas are now recalculated every draw cycle which is a
	// bit silly unless there has been a resize. So to optimize we should
	// use an extra flag or do the calculation in a separate routine.

	const unsigned x = x_(local_variables) * (hdpi_off_[hdpi_x]? 1: twidget::hdpi_scale);
	const unsigned y = y_(local_variables) * (hdpi_off_[hdpi_y]? 1: twidget::hdpi_scale);
	const unsigned w = w_(local_variables) * twidget::hdpi_scale;
	const unsigned h = h_(local_variables) * twidget::hdpi_scale;

	if (share_canvas_integrate) {
		share_canvas_integrate->set_layout_offset(x, y);
	}

	VALIDATE(static_cast<int>(x) < canvas->w && static_cast<int>(y) < canvas->h
			, _("Text doesn't start on canvas."));

	// A text might be to long and will be clipped.
	SDL_Rect clip = ::create_rect(0, 0, surf->w, surf->h);
	if (surf->w > canvas->w) {
		// Text: text is too wide for the canvas and will be clipped.;
		// clip.x += (surf->w - canvas->w) / 2;
		// clip.w -= surf->w - canvas->w;
	}

	if (surf->h > canvas->h) {
		// Text: text is too high for the canvas and will be clipped.
		// extract center. when one line text, top/button aybe hollow.
		clip.y += (surf->h - canvas->h) / 2;
		clip.h -= surf->h - canvas->h;
	}

	// tblend_none_lock lock(surf);

	SDL_Rect dst = ::create_rect(x, y, canvas->w, canvas->h);
	// why not use sdl_blit, see login dialog of war of kingdom.
	blit_surface(surf, &clip, canvas, &dst);
	// sdl_blit(surf, &clip, canvas, &dst);
}

/***** ***** ***** ***** ***** ANIMATION ***** ***** ***** ***** *****/

/** Definition of a animation shape. */
class tanim
	: public tcanvas::tshape
{
public:

	/**
	 * Constructor.
	 *
	 * @param cfg                 The config object to define the text see
	 *                            http://www.wesnoth.org/wiki/GUICanvasWML#Text
	 *                            for more information.
	 */
	explicit tanim(const config& cfg, size_t position);

	/** Implement shape::draw(). */
	void draw(surface& canvas
			, const game_logic::map_formula_callable& variables);

public:
	size_t position_;
	config cfg_;
	int id_;
};

tanim::tanim(const config& cfg, size_t position)
	: tshape(true)
	, position_(position)
	, cfg_(cfg)
	, id_(INVALID_ANIM_ID)
{

/*WIKI
 * @page = GUICanvasWML
 *
 * == Text ==
 * @begin{tag}{name="text"}{min="0"}{max="-1"}
 * Definition of text.
 *
 * Keys:
 * @begin{table}{config}
 *     x & f_unsigned & 0 &            The x coordinate of the top left corner. $
 *     y & f_unsigned & 0 &            The y coordinate of the top left corner. $
 *     w & f_unsigned & 0 &            The width of the text's bounding
 *                                     rectangle. $
 *     h & f_unsigned & 0 &            The height of the text's bounding
 *                                     rectangle. $
 *     font_size & unsigned & &        The size of the text font. $
 *     font_style & font_style & "" &  The style of the text. $
 *     text_alignment & f_h_align & "left" &
 *                                     The alignment of the text. $
 *     color & color & "" &            The color of the text. $
 *     text & f_tstring & "" &         The text to draw (translatable). $
 *     text_markup & f_bool & false &  Can the text have mark-up? $
 *     maximum_width & f_int & -1 &    The maximum width the text is allowed to
 *                                     be. $
 *     maximum_height & f_int & -1 &   The maximum height the text is allowed
 *                                     to be. $
 *     debug & string & "" &           Debug message to show upon creation
 *                                     this message is not stored. $
 * @end{table}
 * @end{tag}{name="text"}
 * NOTE alignment could only be done with the formulas, but now with the
 * text_alignment flag as well, older widgets might still use the formulas and
 * not all widgets may expose the text alignment yet and when exposed not use
 * it yet.
 *
 * Variables:
 * @begin{table}{formula}
 *     text_width & unsigned &            The width of the rendered text. $
 *     text_height & unsigned &           The height of the rendered text. $
 * @end{table}
 * Also the general variables are available, see [[#general_variables|Line]].
 * @end{parent}{name="generic/state/draw/"}
 */
}

void tanim::draw(surface& canvas
		, const game_logic::map_formula_callable& variables)
{
	draw_canvas_anim(*display::get_singleton(), id_, canvas, ::create_rect(0, 0, canvas->w, canvas->h));
}

} // namespace

/***** ***** ***** ***** ***** CANVAS ***** ***** ***** ***** *****/

tcanvas::tcanvas()
	: shapes_()
	, blur_depth_(0)
	, w_(0)
	, h_(0)
	, canvas_()
	, variables_()
	, dirty_(true)
	, anims_()
	, mixed_(false)
{
}

tcanvas::~tcanvas()
{
	display& disp = *display::get_singleton();
	for (std::map<size_t, int>::const_iterator it = anims_.begin(); it != anims_.end(); ++ it) {
		disp.erase_area_anim(it->second);
	}
}

SDL_Rect calculate_screen_clip_rect(int srcw, int srch, const SDL_Surface* dst, SDL_Rect* dstrect)
{
	// function code is copied from SDL_UpperBlit of SDL(SDL_surface.c)
	int srcx, srcy, w, h;

	srcx = srcy = 0;
	w = srcw;
	h = srch;

	{
		const SDL_Rect *clip = &dst->clip_rect;
		int dx, dy;

		dx = clip->x - dstrect->x;
		if (dx > 0) {
			w -= dx;
			dstrect->x += dx;
			srcx += dx;
		}
		dx = dstrect->x + w - clip->x - clip->w;
		if (dx > 0)
			w -= dx;

		dy = clip->y - dstrect->y;
		if (dy > 0) {
			h -= dy;
			dstrect->y += dy;
			srcy += dy;
		}
		dy = dstrect->y + h - clip->y - clip->h;
		if (dy > 0)
			h -= dy;
	}

    if (w > 0 && h > 0) {
        SDL_Rect sr;
        sr.x = srcx;
        sr.y = srcy;
        sr.w = dstrect->w = w;
        sr.h = dstrect->h = h;
        return sr;
    }
	return ::create_rect(0, 0, 0, 0);
}

void tcanvas::draw(surface& frame_buffer, const SDL_Rect& canvas_clip_rect, bool force, const std::vector<int>& pre_anims, const std::vector<int>& post_anims)
{
	bool animated = !anims_.empty() || !pre_anims.empty() || !post_anims.empty();
	if (!animated && share_canvas_integrate && share_canvas_integrate->exist_anim()) {
		animated = true;
	}

	if (!dirty_ && !force && !animated) {
		DBG_GUI_D << "Canvas: nothing to draw.\n";
		return;
	}

	if (dirty_) {
		get_screen_size_variables(variables_);
		variables_.add("width", variant(w_ / twidget::hdpi_scale));
		variables_.add("height", variant(h_ / twidget::hdpi_scale));
		variables_.add("dwidth", variant(w_));
		variables_.add("dheight", variant(h_));
	}

	display& disp = *display::get_singleton();
	if (dirty_ || force || !animated || mixed_ || !pre_anims.empty()) {
		// create surface
		canvas_.assign(create_neutral_surface(w_, h_));

		for (std::vector<int>::const_iterator itor = pre_anims.begin(); itor != pre_anims.end(); ++ itor) {
			draw_canvas_anim(disp, *itor, canvas_, ::create_rect(0, 0, canvas_->w, canvas_->h));
		}

		if (share_canvas_integrate) {
			share_canvas_integrate->draw_bubble_shape(canvas_, variables_);
		}

		// draw items
		for (std::vector<tshape_ptr>::iterator itor = shapes_.begin(); itor != shapes_.end(); ++ itor) {
			if ((*itor)->anim) {
				// this is animation shape
				tanim* anim = dynamic_cast<tanim*>(&**itor);
				anim->id_ = anims_.find(anim->position_)->second;
			}

			(*itor)->draw(canvas_, variables_);
		}

		if (share_canvas_integrate) {
			share_canvas_integrate->animated_draw(disp, canvas_, canvas_clip_rect);
		}

		for (std::vector<int>::const_iterator itor = post_anims.begin(); itor != post_anims.end(); ++ itor) {
			draw_canvas_anim(disp, *itor, canvas_, ::create_rect(0, 0, canvas_->w, canvas_->h));
		}

	} else {
		// undraw
		for (std::vector<int>::const_reverse_iterator ritor = post_anims.rbegin(); ritor != post_anims.rend(); ++ ritor) {
			float_animation& anim = *dynamic_cast<float_animation*>(&disp.area_anim(*ritor));
			anim.undraw(canvas_);
		}

		if (share_canvas_integrate) {
			share_canvas_integrate->animated_undraw(disp, canvas_, canvas_clip_rect);
		}

		for (std::vector<tshape_ptr>::reverse_iterator ritor = shapes_.rbegin(); ritor != shapes_.rend(); ++ ritor) {
			if (!(*ritor)->anim) {
				break;
			}
			// this is animation shape
			int id = anims_.find(dynamic_cast<tanim*>(&**ritor)->position_)->second;
			float_animation& anim = *dynamic_cast<float_animation*>(&disp.area_anim(id));
			anim.undraw(canvas_);
		}

		for (std::vector<tshape_ptr>::iterator itor = shapes_.begin(); itor != shapes_.end(); ++itor) {
			if ((*itor)->anim) {
				// this is animation shape
				tanim* anim = dynamic_cast<tanim*>(&**itor);
				anim->id_ = anims_.find(anim->position_)->second;
			} else {
				continue;
			}

			(*itor)->draw(canvas_, variables_);
		}

		if (share_canvas_integrate) {
			share_canvas_integrate->animated_draw(disp, canvas_, canvas_clip_rect);
		}

		for (std::vector<int>::const_iterator itor = post_anims.begin(); itor != post_anims.end(); ++ itor) {
			draw_canvas_anim(disp, *itor, canvas_, ::create_rect(0, 0, canvas_->w, canvas_->h));
		}
	} 

	dirty_ = false;
}

void tcanvas::blit(surface& surf, SDL_Rect rect, bool force, const std::vector<int>& pre_anims, const std::vector<int>& post_anims)
{
	if (shapes_.empty()) {
		return;
	}

	{
		SDL_Rect r = rect;
		SDL_Rect clip_rect = calculate_screen_clip_rect(w_, h_, surf, &r);
		if (clip_rect.w <= 0 || clip_rect.h <= 0) {
			return;
		}
		draw(surf, clip_rect, force, pre_anims, post_anims);
	}

	if (blur_depth_) {
		if (is_neutral_surface(surf)) {
			blur_surface(surf, rect, blur_depth_);
		} else {
			// Can't directly blur the surface if not 32 bpp.
			SDL_Rect r = rect;
			///@todo we should use: get_surface_portion(surf, r, false)
			///no need to optimize format, since blur_surface will undo it
			surface s = get_surface_portion(surf, r);
			s = blur_surface(s, blur_depth_);
			sdl_blit(s, NULL, surf, &r);
		}
	}

	if (surface_is_opaque.request()) {
		surface_is_opaque.set_retval(is_opaque(canvas_, true));
	}

	sdl_blit(canvas_, NULL, surf, &rect);
}

void tcanvas::parse_cfg(const config& cfg, std::vector<tshape_ptr>& shapes, unsigned* blur_depth)
{
	log_scope2(log_gui_parse, "Canvas: parsing config.");
	shapes.clear();

	BOOST_FOREACH(const config::any_child& shape, cfg.all_children_range()) {
		const std::string &type = shape.key;
		const config &data = shape.cfg;

		DBG_GUI_P << "Canvas: found shape of the type " << type << ".\n";

		if (type == "line") {
			shapes.push_back(new tline(data));
		} else if (type == "rectangle") {
			shapes.push_back(new trectangle(data));
		} else if (type == "circle") {
			shapes.push_back(new tcircle(data));
		} else if (type == "image") {
			shapes.push_back(new timage(data));
		} else if (type == "text") {
			shapes.push_back(new ttext(data));
		} else if (type == "anim") {
			shapes.push_back(new tanim(data, shapes.size()));
		} else if (type == "pre_commit") {

			/* note this should get split if more preprocessing is used. */
			BOOST_FOREACH (const config::any_child& function,
					data.all_children_range()) {

				if (function.key == "blur") {
					if (blur_depth) {
						*blur_depth = function.cfg["depth"];
					}
				} else {
					ERR_GUI_P << "Canvas: found a pre commit function"
							<< " of an invalid type " << type << ".\n";
				}
			}

		} else {
			ERR_GUI_P << "Canvas: found a shape of an invalid type "
					<< type << ".\n";

			assert(false);
		}
	}
}

bool tcanvas::start_animation()
{
	display& disp = *display::get_singleton();
	for (std::vector<tshape_ptr>::iterator it = shapes_.begin(); it != shapes_.end(); ++ it) {
		if (!(*it)->anim) {
			if (!mixed_ && !anims_.empty()) {
				mixed_ = true;
			}
			continue;
		}
		// this is animation shape
		tanim* anim = dynamic_cast<tanim*>(&**it);
		int id = start_cycle_float_anim(disp, anim->cfg_);
		if (id == INVALID_ANIM_ID) {
			continue;
		}
		anims_.insert(std::make_pair(anim->position_, id));
	}
	return !anims_.empty();
}

/***** ***** ***** ***** ***** SHAPE ***** ***** ***** ***** *****/

} // namespace gui2
/*WIKI
 * @page = GUICanvasWML
 * @order = ZZZZZZ_footer
 *
 * [[Category: WML Reference]]
 * [[Category: GUI WML Reference]]
 *
 */

/*WIKI
 * @page = GUIVariable
 * @order = ZZZZZZ_footer
 *
 * [[Category: WML Reference]]
 * [[Category: GUI WML Reference]]
 */
